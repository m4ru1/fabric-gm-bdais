// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"hash"
	"sync"

	"github.com/hyperledger/fabric/bccsp"
)

type BCCSP struct {
	DecryptStub        func(bccsp.Key, []byte, bccsp.DecrypterOpts) ([]byte, error)
	decryptMutex       sync.RWMutex
	decryptArgsForCall []struct {
		arg1 bccsp.Key
		arg2 []byte
		arg3 bccsp.DecrypterOpts
	}
	decryptReturns struct {
		result1 []byte
		result2 error
	}
	decryptReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	EncryptStub        func(bccsp.Key, []byte, bccsp.EncrypterOpts) ([]byte, error)
	encryptMutex       sync.RWMutex
	encryptArgsForCall []struct {
		arg1 bccsp.Key
		arg2 []byte
		arg3 bccsp.EncrypterOpts
	}
	encryptReturns struct {
		result1 []byte
		result2 error
	}
	encryptReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	GetHashStub        func(bccsp.HashOpts) (hash.Hash, error)
	getHashMutex       sync.RWMutex
	getHashArgsForCall []struct {
		arg1 bccsp.HashOpts
	}
	getHashReturns struct {
		result1 hash.Hash
		result2 error
	}
	getHashReturnsOnCall map[int]struct {
		result1 hash.Hash
		result2 error
	}
	GetKeyStub        func([]byte) (bccsp.Key, error)
	getKeyMutex       sync.RWMutex
	getKeyArgsForCall []struct {
		arg1 []byte
	}
	getKeyReturns struct {
		result1 bccsp.Key
		result2 error
	}
	getKeyReturnsOnCall map[int]struct {
		result1 bccsp.Key
		result2 error
	}
	HashStub        func([]byte, bccsp.HashOpts) ([]byte, error)
	hashMutex       sync.RWMutex
	hashArgsForCall []struct {
		arg1 []byte
		arg2 bccsp.HashOpts
	}
	hashReturns struct {
		result1 []byte
		result2 error
	}
	hashReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	KeyDerivStub        func(bccsp.Key, bccsp.KeyDerivOpts) (bccsp.Key, error)
	keyDerivMutex       sync.RWMutex
	keyDerivArgsForCall []struct {
		arg1 bccsp.Key
		arg2 bccsp.KeyDerivOpts
	}
	keyDerivReturns struct {
		result1 bccsp.Key
		result2 error
	}
	keyDerivReturnsOnCall map[int]struct {
		result1 bccsp.Key
		result2 error
	}
	KeyGenStub        func(bccsp.KeyGenOpts) (bccsp.Key, error)
	keyGenMutex       sync.RWMutex
	keyGenArgsForCall []struct {
		arg1 bccsp.KeyGenOpts
	}
	keyGenReturns struct {
		result1 bccsp.Key
		result2 error
	}
	keyGenReturnsOnCall map[int]struct {
		result1 bccsp.Key
		result2 error
	}
	KeyImportStub        func(interface{}, bccsp.KeyImportOpts) (bccsp.Key, error)
	keyImportMutex       sync.RWMutex
	keyImportArgsForCall []struct {
		arg1 interface{}
		arg2 bccsp.KeyImportOpts
	}
	keyImportReturns struct {
		result1 bccsp.Key
		result2 error
	}
	keyImportReturnsOnCall map[int]struct {
		result1 bccsp.Key
		result2 error
	}
	SignStub        func(bccsp.Key, []byte, bccsp.SignerOpts) ([]byte, error)
	signMutex       sync.RWMutex
	signArgsForCall []struct {
		arg1 bccsp.Key
		arg2 []byte
		arg3 bccsp.SignerOpts
	}
	signReturns struct {
		result1 []byte
		result2 error
	}
	signReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	VerifyStub        func(bccsp.Key, []byte, []byte, bccsp.SignerOpts) (bool, error)
	verifyMutex       sync.RWMutex
	verifyArgsForCall []struct {
		arg1 bccsp.Key
		arg2 []byte
		arg3 []byte
		arg4 bccsp.SignerOpts
	}
	verifyReturns struct {
		result1 bool
		result2 error
	}
	verifyReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *BCCSP) Decrypt(arg1 bccsp.Key, arg2 []byte, arg3 bccsp.DecrypterOpts) ([]byte, error) {
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.decryptMutex.Lock()
	ret, specificReturn := fake.decryptReturnsOnCall[len(fake.decryptArgsForCall)]
	fake.decryptArgsForCall = append(fake.decryptArgsForCall, struct {
		arg1 bccsp.Key
		arg2 []byte
		arg3 bccsp.DecrypterOpts
	}{arg1, arg2Copy, arg3})
	stub := fake.DecryptStub
	fakeReturns := fake.decryptReturns
	fake.recordInvocation("Decrypt", []interface{}{arg1, arg2Copy, arg3})
	fake.decryptMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *BCCSP) DecryptCallCount() int {
	fake.decryptMutex.RLock()
	defer fake.decryptMutex.RUnlock()
	return len(fake.decryptArgsForCall)
}

func (fake *BCCSP) DecryptCalls(stub func(bccsp.Key, []byte, bccsp.DecrypterOpts) ([]byte, error)) {
	fake.decryptMutex.Lock()
	defer fake.decryptMutex.Unlock()
	fake.DecryptStub = stub
}

func (fake *BCCSP) DecryptArgsForCall(i int) (bccsp.Key, []byte, bccsp.DecrypterOpts) {
	fake.decryptMutex.RLock()
	defer fake.decryptMutex.RUnlock()
	argsForCall := fake.decryptArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *BCCSP) DecryptReturns(result1 []byte, result2 error) {
	fake.decryptMutex.Lock()
	defer fake.decryptMutex.Unlock()
	fake.DecryptStub = nil
	fake.decryptReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *BCCSP) DecryptReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.decryptMutex.Lock()
	defer fake.decryptMutex.Unlock()
	fake.DecryptStub = nil
	if fake.decryptReturnsOnCall == nil {
		fake.decryptReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.decryptReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *BCCSP) Encrypt(arg1 bccsp.Key, arg2 []byte, arg3 bccsp.EncrypterOpts) ([]byte, error) {
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.encryptMutex.Lock()
	ret, specificReturn := fake.encryptReturnsOnCall[len(fake.encryptArgsForCall)]
	fake.encryptArgsForCall = append(fake.encryptArgsForCall, struct {
		arg1 bccsp.Key
		arg2 []byte
		arg3 bccsp.EncrypterOpts
	}{arg1, arg2Copy, arg3})
	stub := fake.EncryptStub
	fakeReturns := fake.encryptReturns
	fake.recordInvocation("Encrypt", []interface{}{arg1, arg2Copy, arg3})
	fake.encryptMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *BCCSP) EncryptCallCount() int {
	fake.encryptMutex.RLock()
	defer fake.encryptMutex.RUnlock()
	return len(fake.encryptArgsForCall)
}

func (fake *BCCSP) EncryptCalls(stub func(bccsp.Key, []byte, bccsp.EncrypterOpts) ([]byte, error)) {
	fake.encryptMutex.Lock()
	defer fake.encryptMutex.Unlock()
	fake.EncryptStub = stub
}

func (fake *BCCSP) EncryptArgsForCall(i int) (bccsp.Key, []byte, bccsp.EncrypterOpts) {
	fake.encryptMutex.RLock()
	defer fake.encryptMutex.RUnlock()
	argsForCall := fake.encryptArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *BCCSP) EncryptReturns(result1 []byte, result2 error) {
	fake.encryptMutex.Lock()
	defer fake.encryptMutex.Unlock()
	fake.EncryptStub = nil
	fake.encryptReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *BCCSP) EncryptReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.encryptMutex.Lock()
	defer fake.encryptMutex.Unlock()
	fake.EncryptStub = nil
	if fake.encryptReturnsOnCall == nil {
		fake.encryptReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.encryptReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *BCCSP) GetHash(arg1 bccsp.HashOpts) (hash.Hash, error) {
	fake.getHashMutex.Lock()
	ret, specificReturn := fake.getHashReturnsOnCall[len(fake.getHashArgsForCall)]
	fake.getHashArgsForCall = append(fake.getHashArgsForCall, struct {
		arg1 bccsp.HashOpts
	}{arg1})
	stub := fake.GetHashStub
	fakeReturns := fake.getHashReturns
	fake.recordInvocation("GetHash", []interface{}{arg1})
	fake.getHashMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *BCCSP) GetHashCallCount() int {
	fake.getHashMutex.RLock()
	defer fake.getHashMutex.RUnlock()
	return len(fake.getHashArgsForCall)
}

func (fake *BCCSP) GetHashCalls(stub func(bccsp.HashOpts) (hash.Hash, error)) {
	fake.getHashMutex.Lock()
	defer fake.getHashMutex.Unlock()
	fake.GetHashStub = stub
}

func (fake *BCCSP) GetHashArgsForCall(i int) bccsp.HashOpts {
	fake.getHashMutex.RLock()
	defer fake.getHashMutex.RUnlock()
	argsForCall := fake.getHashArgsForCall[i]
	return argsForCall.arg1
}

func (fake *BCCSP) GetHashReturns(result1 hash.Hash, result2 error) {
	fake.getHashMutex.Lock()
	defer fake.getHashMutex.Unlock()
	fake.GetHashStub = nil
	fake.getHashReturns = struct {
		result1 hash.Hash
		result2 error
	}{result1, result2}
}

func (fake *BCCSP) GetHashReturnsOnCall(i int, result1 hash.Hash, result2 error) {
	fake.getHashMutex.Lock()
	defer fake.getHashMutex.Unlock()
	fake.GetHashStub = nil
	if fake.getHashReturnsOnCall == nil {
		fake.getHashReturnsOnCall = make(map[int]struct {
			result1 hash.Hash
			result2 error
		})
	}
	fake.getHashReturnsOnCall[i] = struct {
		result1 hash.Hash
		result2 error
	}{result1, result2}
}

func (fake *BCCSP) GetKey(arg1 []byte) (bccsp.Key, error) {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.getKeyMutex.Lock()
	ret, specificReturn := fake.getKeyReturnsOnCall[len(fake.getKeyArgsForCall)]
	fake.getKeyArgsForCall = append(fake.getKeyArgsForCall, struct {
		arg1 []byte
	}{arg1Copy})
	stub := fake.GetKeyStub
	fakeReturns := fake.getKeyReturns
	fake.recordInvocation("GetKey", []interface{}{arg1Copy})
	fake.getKeyMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *BCCSP) GetKeyCallCount() int {
	fake.getKeyMutex.RLock()
	defer fake.getKeyMutex.RUnlock()
	return len(fake.getKeyArgsForCall)
}

func (fake *BCCSP) GetKeyCalls(stub func([]byte) (bccsp.Key, error)) {
	fake.getKeyMutex.Lock()
	defer fake.getKeyMutex.Unlock()
	fake.GetKeyStub = stub
}

func (fake *BCCSP) GetKeyArgsForCall(i int) []byte {
	fake.getKeyMutex.RLock()
	defer fake.getKeyMutex.RUnlock()
	argsForCall := fake.getKeyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *BCCSP) GetKeyReturns(result1 bccsp.Key, result2 error) {
	fake.getKeyMutex.Lock()
	defer fake.getKeyMutex.Unlock()
	fake.GetKeyStub = nil
	fake.getKeyReturns = struct {
		result1 bccsp.Key
		result2 error
	}{result1, result2}
}

func (fake *BCCSP) GetKeyReturnsOnCall(i int, result1 bccsp.Key, result2 error) {
	fake.getKeyMutex.Lock()
	defer fake.getKeyMutex.Unlock()
	fake.GetKeyStub = nil
	if fake.getKeyReturnsOnCall == nil {
		fake.getKeyReturnsOnCall = make(map[int]struct {
			result1 bccsp.Key
			result2 error
		})
	}
	fake.getKeyReturnsOnCall[i] = struct {
		result1 bccsp.Key
		result2 error
	}{result1, result2}
}

func (fake *BCCSP) Hash(arg1 []byte, arg2 bccsp.HashOpts) ([]byte, error) {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.hashMutex.Lock()
	ret, specificReturn := fake.hashReturnsOnCall[len(fake.hashArgsForCall)]
	fake.hashArgsForCall = append(fake.hashArgsForCall, struct {
		arg1 []byte
		arg2 bccsp.HashOpts
	}{arg1Copy, arg2})
	stub := fake.HashStub
	fakeReturns := fake.hashReturns
	fake.recordInvocation("Hash", []interface{}{arg1Copy, arg2})
	fake.hashMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *BCCSP) HashCallCount() int {
	fake.hashMutex.RLock()
	defer fake.hashMutex.RUnlock()
	return len(fake.hashArgsForCall)
}

func (fake *BCCSP) HashCalls(stub func([]byte, bccsp.HashOpts) ([]byte, error)) {
	fake.hashMutex.Lock()
	defer fake.hashMutex.Unlock()
	fake.HashStub = stub
}

func (fake *BCCSP) HashArgsForCall(i int) ([]byte, bccsp.HashOpts) {
	fake.hashMutex.RLock()
	defer fake.hashMutex.RUnlock()
	argsForCall := fake.hashArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *BCCSP) HashReturns(result1 []byte, result2 error) {
	fake.hashMutex.Lock()
	defer fake.hashMutex.Unlock()
	fake.HashStub = nil
	fake.hashReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *BCCSP) HashReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.hashMutex.Lock()
	defer fake.hashMutex.Unlock()
	fake.HashStub = nil
	if fake.hashReturnsOnCall == nil {
		fake.hashReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.hashReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *BCCSP) KeyDeriv(arg1 bccsp.Key, arg2 bccsp.KeyDerivOpts) (bccsp.Key, error) {
	fake.keyDerivMutex.Lock()
	ret, specificReturn := fake.keyDerivReturnsOnCall[len(fake.keyDerivArgsForCall)]
	fake.keyDerivArgsForCall = append(fake.keyDerivArgsForCall, struct {
		arg1 bccsp.Key
		arg2 bccsp.KeyDerivOpts
	}{arg1, arg2})
	stub := fake.KeyDerivStub
	fakeReturns := fake.keyDerivReturns
	fake.recordInvocation("KeyDeriv", []interface{}{arg1, arg2})
	fake.keyDerivMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *BCCSP) KeyDerivCallCount() int {
	fake.keyDerivMutex.RLock()
	defer fake.keyDerivMutex.RUnlock()
	return len(fake.keyDerivArgsForCall)
}

func (fake *BCCSP) KeyDerivCalls(stub func(bccsp.Key, bccsp.KeyDerivOpts) (bccsp.Key, error)) {
	fake.keyDerivMutex.Lock()
	defer fake.keyDerivMutex.Unlock()
	fake.KeyDerivStub = stub
}

func (fake *BCCSP) KeyDerivArgsForCall(i int) (bccsp.Key, bccsp.KeyDerivOpts) {
	fake.keyDerivMutex.RLock()
	defer fake.keyDerivMutex.RUnlock()
	argsForCall := fake.keyDerivArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *BCCSP) KeyDerivReturns(result1 bccsp.Key, result2 error) {
	fake.keyDerivMutex.Lock()
	defer fake.keyDerivMutex.Unlock()
	fake.KeyDerivStub = nil
	fake.keyDerivReturns = struct {
		result1 bccsp.Key
		result2 error
	}{result1, result2}
}

func (fake *BCCSP) KeyDerivReturnsOnCall(i int, result1 bccsp.Key, result2 error) {
	fake.keyDerivMutex.Lock()
	defer fake.keyDerivMutex.Unlock()
	fake.KeyDerivStub = nil
	if fake.keyDerivReturnsOnCall == nil {
		fake.keyDerivReturnsOnCall = make(map[int]struct {
			result1 bccsp.Key
			result2 error
		})
	}
	fake.keyDerivReturnsOnCall[i] = struct {
		result1 bccsp.Key
		result2 error
	}{result1, result2}
}

func (fake *BCCSP) KeyGen(arg1 bccsp.KeyGenOpts) (bccsp.Key, error) {
	fake.keyGenMutex.Lock()
	ret, specificReturn := fake.keyGenReturnsOnCall[len(fake.keyGenArgsForCall)]
	fake.keyGenArgsForCall = append(fake.keyGenArgsForCall, struct {
		arg1 bccsp.KeyGenOpts
	}{arg1})
	stub := fake.KeyGenStub
	fakeReturns := fake.keyGenReturns
	fake.recordInvocation("KeyGen", []interface{}{arg1})
	fake.keyGenMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *BCCSP) KeyGenCallCount() int {
	fake.keyGenMutex.RLock()
	defer fake.keyGenMutex.RUnlock()
	return len(fake.keyGenArgsForCall)
}

func (fake *BCCSP) KeyGenCalls(stub func(bccsp.KeyGenOpts) (bccsp.Key, error)) {
	fake.keyGenMutex.Lock()
	defer fake.keyGenMutex.Unlock()
	fake.KeyGenStub = stub
}

func (fake *BCCSP) KeyGenArgsForCall(i int) bccsp.KeyGenOpts {
	fake.keyGenMutex.RLock()
	defer fake.keyGenMutex.RUnlock()
	argsForCall := fake.keyGenArgsForCall[i]
	return argsForCall.arg1
}

func (fake *BCCSP) KeyGenReturns(result1 bccsp.Key, result2 error) {
	fake.keyGenMutex.Lock()
	defer fake.keyGenMutex.Unlock()
	fake.KeyGenStub = nil
	fake.keyGenReturns = struct {
		result1 bccsp.Key
		result2 error
	}{result1, result2}
}

func (fake *BCCSP) KeyGenReturnsOnCall(i int, result1 bccsp.Key, result2 error) {
	fake.keyGenMutex.Lock()
	defer fake.keyGenMutex.Unlock()
	fake.KeyGenStub = nil
	if fake.keyGenReturnsOnCall == nil {
		fake.keyGenReturnsOnCall = make(map[int]struct {
			result1 bccsp.Key
			result2 error
		})
	}
	fake.keyGenReturnsOnCall[i] = struct {
		result1 bccsp.Key
		result2 error
	}{result1, result2}
}

func (fake *BCCSP) KeyImport(arg1 interface{}, arg2 bccsp.KeyImportOpts) (bccsp.Key, error) {
	fake.keyImportMutex.Lock()
	ret, specificReturn := fake.keyImportReturnsOnCall[len(fake.keyImportArgsForCall)]
	fake.keyImportArgsForCall = append(fake.keyImportArgsForCall, struct {
		arg1 interface{}
		arg2 bccsp.KeyImportOpts
	}{arg1, arg2})
	stub := fake.KeyImportStub
	fakeReturns := fake.keyImportReturns
	fake.recordInvocation("KeyImport", []interface{}{arg1, arg2})
	fake.keyImportMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *BCCSP) KeyImportCallCount() int {
	fake.keyImportMutex.RLock()
	defer fake.keyImportMutex.RUnlock()
	return len(fake.keyImportArgsForCall)
}

func (fake *BCCSP) KeyImportCalls(stub func(interface{}, bccsp.KeyImportOpts) (bccsp.Key, error)) {
	fake.keyImportMutex.Lock()
	defer fake.keyImportMutex.Unlock()
	fake.KeyImportStub = stub
}

func (fake *BCCSP) KeyImportArgsForCall(i int) (interface{}, bccsp.KeyImportOpts) {
	fake.keyImportMutex.RLock()
	defer fake.keyImportMutex.RUnlock()
	argsForCall := fake.keyImportArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *BCCSP) KeyImportReturns(result1 bccsp.Key, result2 error) {
	fake.keyImportMutex.Lock()
	defer fake.keyImportMutex.Unlock()
	fake.KeyImportStub = nil
	fake.keyImportReturns = struct {
		result1 bccsp.Key
		result2 error
	}{result1, result2}
}

func (fake *BCCSP) KeyImportReturnsOnCall(i int, result1 bccsp.Key, result2 error) {
	fake.keyImportMutex.Lock()
	defer fake.keyImportMutex.Unlock()
	fake.KeyImportStub = nil
	if fake.keyImportReturnsOnCall == nil {
		fake.keyImportReturnsOnCall = make(map[int]struct {
			result1 bccsp.Key
			result2 error
		})
	}
	fake.keyImportReturnsOnCall[i] = struct {
		result1 bccsp.Key
		result2 error
	}{result1, result2}
}

func (fake *BCCSP) Sign(arg1 bccsp.Key, arg2 []byte, arg3 bccsp.SignerOpts) ([]byte, error) {
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.signMutex.Lock()
	ret, specificReturn := fake.signReturnsOnCall[len(fake.signArgsForCall)]
	fake.signArgsForCall = append(fake.signArgsForCall, struct {
		arg1 bccsp.Key
		arg2 []byte
		arg3 bccsp.SignerOpts
	}{arg1, arg2Copy, arg3})
	stub := fake.SignStub
	fakeReturns := fake.signReturns
	fake.recordInvocation("Sign", []interface{}{arg1, arg2Copy, arg3})
	fake.signMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *BCCSP) SignCallCount() int {
	fake.signMutex.RLock()
	defer fake.signMutex.RUnlock()
	return len(fake.signArgsForCall)
}

func (fake *BCCSP) SignCalls(stub func(bccsp.Key, []byte, bccsp.SignerOpts) ([]byte, error)) {
	fake.signMutex.Lock()
	defer fake.signMutex.Unlock()
	fake.SignStub = stub
}

func (fake *BCCSP) SignArgsForCall(i int) (bccsp.Key, []byte, bccsp.SignerOpts) {
	fake.signMutex.RLock()
	defer fake.signMutex.RUnlock()
	argsForCall := fake.signArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *BCCSP) SignReturns(result1 []byte, result2 error) {
	fake.signMutex.Lock()
	defer fake.signMutex.Unlock()
	fake.SignStub = nil
	fake.signReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *BCCSP) SignReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.signMutex.Lock()
	defer fake.signMutex.Unlock()
	fake.SignStub = nil
	if fake.signReturnsOnCall == nil {
		fake.signReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.signReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *BCCSP) Verify(arg1 bccsp.Key, arg2 []byte, arg3 []byte, arg4 bccsp.SignerOpts) (bool, error) {
	var arg2Copy []byte
	if arg2 != nil {
		arg2Copy = make([]byte, len(arg2))
		copy(arg2Copy, arg2)
	}
	var arg3Copy []byte
	if arg3 != nil {
		arg3Copy = make([]byte, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.verifyMutex.Lock()
	ret, specificReturn := fake.verifyReturnsOnCall[len(fake.verifyArgsForCall)]
	fake.verifyArgsForCall = append(fake.verifyArgsForCall, struct {
		arg1 bccsp.Key
		arg2 []byte
		arg3 []byte
		arg4 bccsp.SignerOpts
	}{arg1, arg2Copy, arg3Copy, arg4})
	stub := fake.VerifyStub
	fakeReturns := fake.verifyReturns
	fake.recordInvocation("Verify", []interface{}{arg1, arg2Copy, arg3Copy, arg4})
	fake.verifyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *BCCSP) VerifyCallCount() int {
	fake.verifyMutex.RLock()
	defer fake.verifyMutex.RUnlock()
	return len(fake.verifyArgsForCall)
}

func (fake *BCCSP) VerifyCalls(stub func(bccsp.Key, []byte, []byte, bccsp.SignerOpts) (bool, error)) {
	fake.verifyMutex.Lock()
	defer fake.verifyMutex.Unlock()
	fake.VerifyStub = stub
}

func (fake *BCCSP) VerifyArgsForCall(i int) (bccsp.Key, []byte, []byte, bccsp.SignerOpts) {
	fake.verifyMutex.RLock()
	defer fake.verifyMutex.RUnlock()
	argsForCall := fake.verifyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *BCCSP) VerifyReturns(result1 bool, result2 error) {
	fake.verifyMutex.Lock()
	defer fake.verifyMutex.Unlock()
	fake.VerifyStub = nil
	fake.verifyReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *BCCSP) VerifyReturnsOnCall(i int, result1 bool, result2 error) {
	fake.verifyMutex.Lock()
	defer fake.verifyMutex.Unlock()
	fake.VerifyStub = nil
	if fake.verifyReturnsOnCall == nil {
		fake.verifyReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.verifyReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *BCCSP) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.decryptMutex.RLock()
	defer fake.decryptMutex.RUnlock()
	fake.encryptMutex.RLock()
	defer fake.encryptMutex.RUnlock()
	fake.getHashMutex.RLock()
	defer fake.getHashMutex.RUnlock()
	fake.getKeyMutex.RLock()
	defer fake.getKeyMutex.RUnlock()
	fake.hashMutex.RLock()
	defer fake.hashMutex.RUnlock()
	fake.keyDerivMutex.RLock()
	defer fake.keyDerivMutex.RUnlock()
	fake.keyGenMutex.RLock()
	defer fake.keyGenMutex.RUnlock()
	fake.keyImportMutex.RLock()
	defer fake.keyImportMutex.RUnlock()
	fake.signMutex.RLock()
	defer fake.signMutex.RUnlock()
	fake.verifyMutex.RLock()
	defer fake.verifyMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *BCCSP) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}
